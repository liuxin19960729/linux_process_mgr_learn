# 调度
```c
struct task_struc {
    unsigned int policy;//调度策略
    // 优先级
    // 实时进程 [0,99] 
    // 普通进程 [100,139]
    int				prio;
	int				static_prio;
	int				normal_prio;
	unsigned int			rt_priority;
}

/*
 * Scheduling policies
 */
#define SCHED_NORMAL		0
#define SCHED_FIFO		1
#define SCHED_RR		2
#define SCHED_BATCH		3
/* SCHED_ISO: reserved but not implemented yet */
#define SCHED_IDLE		5
#define SCHED_DEADLINE		6

```

## 实时调度策略
```c
#define SCHED_FIFO		1
    优先级高的抢占优先级低的
    相同优先级先来先执行
#define SCHED_RR		2
    轮流调度算法
    相同优先级用完时间盘放在队列尾部
    高优先级可以抢占优先级低的任务
#define SCHED_DEADLINE		6
    按照deadline调度,按照时间最近的deadlie调度
```

## 普通调度
```c
// 普通进程 
#define SCHED_NORMAL		0
// 后台进程 默默执行 优先级不需要特别的高
#define SCHED_BATCH		3
/* SCHED_ISO: reserved but not implemented yet */
// 当特备空闲的时候执行
#define SCHED_IDLE		5


struct task_struct{
    const struct sched_class	*sched_class;
}


sched_class 的几种实现

extern const struct sched_class stop_sched_class;
    优先级最高的任务使用该策略,中断所有进程 不会被其他进程中断
extern const struct sched_class dl_sched_class;
    deadline 调度策略
extern const struct sched_class rt_sched_class;
    rr or fifo 调度
    根据 task_policy 指定
extern const struct sched_class fair_sched_class;
    普通进程调度策略
extern const struct sched_class idle_sched_class;
    空闲进程调度策略


```

### 完全公平调度算法
```c
CFS(completely fair scheduling)
    cpu 每段时间滴答(触发时钟中断 tick)
tick 到来 vruntime 不断增大


虚拟运行时间 vruntime += 实际运行时间 delta_exec * NICE_0_LOAD/ 权重

同一运行时间的情况下
权重 越大 vruntime 越小
```

### 调度队列和调度实体
```c
排序进程 找出最小 ,能够快速的更新task 数据

平衡查询和跟新选择红黑树数据结构

struct task_struct{
    struct sched_entity se;
    // 实时调度实体
    struct sched_rt_entity rt;
    // deadline 调度实体
    struct sched_dl_entity dl;
}

```